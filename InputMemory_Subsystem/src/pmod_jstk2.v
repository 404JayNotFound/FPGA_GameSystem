/********************************************************************
* Module: pmod_jstk2
* Author: Jamie O'Connor
* Date: 21-Nov-2025
* Description:
*   SPI Master Module designed to interface with the Digilent Pmod JSTK2.
*   Implements the standard 5-byte read protocol, including the required
*   microsecond-level timing delays (CS setup, interbyte, post-transfer)
*   as specified in the Pmod JSTK2 documentation.
*   Parses the 40-bit MISO data stream into:
*     - 16-bit X-axis position
*     - 16-bit Y-axis position
*     - 8-bit button status byte
*     - Individual trigger and joystick button signals
*
* Inputs:
*   clk             - System clock
*   reset           - Asynchronous reset (active high)
*   start_read      - Pulse to initiate a 5-byte SPI read transaction
*   miso            - Master-In, Slave-Out (data from the Pmod JSTK2)
*
* Outputs:
*   sck             - SPI serial clock (generated by master)
*   cs_n            - Chip select (active low)
*   mosi            - Master-Out, Slave-In (tied low, unused)
*   x_position      - 16-bit X-axis position
*   y_position      - 16-bit Y-axis position
*   fs_buttons      - 8-bit raw button status
*   btn_jstk        - Center joystick button
*   btn_trigger     - Trigger button
*   data_valid      - Pulses high when a new 5-byte packet is available
*   read_in_progress- High during SPI transaction
*
* Parameters:
*   SCK_DIVIDER          - Divisor to generate SCK from system clock
*   CS_WAIT_CYCLES       - Delay cycles after CS low before first byte (≥15 us)
*   INTERBYTE_WAIT_CYCLES- Delay cycles between bytes (≥10 us)
*   POST_WAIT_CYCLES     - Delay cycles after CS high before next transaction (≥25 us)
*
* Notes:
*   - Designed to work with a 100 MHz system clock
*   - SPI sampling is MSB-first
*   - Uses FSM to handle all delays and bit shifting reliably
*
********************************************************************/

`timescale 1ns/1ps
module pmod_jstk2 (
    input  wire       clk,
    input  wire       reset,
    input  wire       start_read,
    input  wire       miso,
    output reg        sck,
    output reg        cs_n,
    output wire       mosi,
    output reg [15:0] x_position,
    output reg [15:0] y_position,
    output reg [7:0]  fs_buttons,
    output reg        btn_jstk,
    output reg        btn_trigger,
    output reg        data_valid,
    output wire       read_in_progress
);

    // Parameters
    parameter SCK_DIVIDER           = 20;    // 100MHz / 20 → 2.5MHz SCK (Min 2MHz for JSTK2)
    parameter CS_WAIT_CYCLES        = 1500;  // 15 us @ 100MHz
    parameter INTERBYTE_WAIT_CYCLES = 1000;  // 10 us @ 100MHz
    parameter POST_WAIT_CYCLES      = 2500;  // 25 us @ 100MHz

    // FSM States
    localparam [3:0] 
        IDLE            = 0,
        CS_ASSERT       = 1,
        WAIT_CS_DELAY   = 2,
        SHIFT_BYTE      = 3,
        WAIT_INTERBYTE  = 4,
        CS_DEASSERT     = 5,
        WAIT_POST_DELAY = 6;

    // Internal Signals
    reg [4:0]  sck_count;
    wire       sck_tick;
    reg [3:0]  current_state, next_state;
    reg [6:0]  bit_count;
    reg [11:0] delay_count;
    reg [39:0] received_data;

    assign mosi = 1'b0;
    assign read_in_progress = (current_state != IDLE) && (current_state != WAIT_POST_DELAY);

    always @(posedge clk or posedge reset) begin
        if (reset) begin
            sck <= 0;
            sck_count <= 0;
        end else if (current_state == SHIFT_BYTE) begin
            if (sck_count == SCK_DIVIDER-1) begin
                sck_count <= 0;
                sck <= ~sck;
            end else begin
                sck_count <= sck_count + 1;
            end
        end else begin
            sck <= 0;
            sck_count <= 0;
        end
    end

    assign sck_tick = (current_state == SHIFT_BYTE) && (sck_count == SCK_DIVIDER-1) && (sck == 0);

    // FSM Sequential Logic
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 0;
            delay_count <= 0;
            received_data <= 0;
            x_position <= 0;
            y_position <= 0;
            fs_buttons <= 0;
            btn_jstk <= 0;
            btn_trigger <= 0;
            data_valid <= 0;
            cs_n <= 1;
        end else begin
            current_state <= next_state;

            if (current_state == WAIT_CS_DELAY || current_state == WAIT_INTERBYTE || current_state == WAIT_POST_DELAY) begin
                delay_count <= delay_count + 1;
            end else begin
                delay_count <= 0;
            end

            if (current_state == SHIFT_BYTE && sck_tick) begin
                received_data <= {miso, received_data[39:1]};
                bit_count <= bit_count + 1;
            end else if (next_state == CS_ASSERT) begin
                bit_count <= 0;
                received_data <= 0;
            end
        end
    end
    
    always @(*) begin
        next_state = current_state;
        cs_n = 1'b1;
        data_valid = 0;

        x_position = x_position;
        y_position = y_position;
        fs_buttons = fs_buttons;
        btn_jstk = btn_jstk;
        btn_trigger = btn_trigger;
        
        case(current_state)
            IDLE:
                if (start_read) next_state = CS_ASSERT;

            CS_ASSERT: begin
                cs_n = 0;
                next_state = WAIT_CS_DELAY;
            end

            WAIT_CS_DELAY: begin
                cs_n = 0;
                if (delay_count >= CS_WAIT_CYCLES)
                    next_state = SHIFT_BYTE;
            end

            SHIFT_BYTE: begin
                cs_n = 0;
                if (sck_tick) begin
                    if (bit_count == 39)
                        next_state = CS_DEASSERT;
                    else if (bit_count[2:0] == 7)
                        next_state = WAIT_INTERBYTE;
                end
            end

            WAIT_INTERBYTE: begin
                cs_n = 0;
                if (delay_count >= INTERBYTE_WAIT_CYCLES)
                    next_state = SHIFT_BYTE;
            end

            CS_DEASSERT: begin
                cs_n = 1;
                data_valid = 1;

                // Parse received data
                x_position = {received_data[31:24], received_data[39:32]};
                y_position = {received_data[15:8], received_data[23:16]};
                fs_buttons = received_data[7:0];
                btn_trigger = received_data[1];
                btn_jstk = received_data[0];

                next_state = WAIT_POST_DELAY;
            end

            WAIT_POST_DELAY: begin
                cs_n = 1;
                if (delay_count >= POST_WAIT_CYCLES)
                    next_state = IDLE;
            end

            default: next_state = IDLE;
        endcase
    end

endmodule
