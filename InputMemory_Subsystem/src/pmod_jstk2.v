/********************************************************************
* Module: pmod_jstk2
* Author: Jamie O'Connor
* Date: 21-Nov-2025
* Description:
*   SPI Master Module designed to interface with the Digilent Pmod JSTK2.
*   Implements the standard 5-byte read protocol, including necessary
*   timing delays (CS setup, interbyte, post-transfer) as specified in the
*   Pmod JSTK2 documentation.
*   Parses the 40-bit data stream into 16-bit X/Y positions and button states.
*
* Inputs:
*   clk                 - System clock
*   reset               - Asynchronous reset (active high)
*   start_read          - Pulse to initiate a new 5-byte SPI read transaction
*   miso                - Master-In, Slave-Out (Data from Pmod JSTK2)
*
* Outputs:
*   sck                 - Serial Clock (generated by Master)
*   cs_n                - Chip Select (active low)
*   mosi                - Master-Out, Slave-In
*   x_position          - 16-bit calibrated X-axis position 
*   y_position          - 16-bit calibrated Y-axis position
*   fs_buttons          - 8-bit raw button status byte
*   btn_jstk            - Center joystick button status
*   btn_trigger         - Trigger button status
*   data_valid          - Pulse high when new data is available in output registers
*   read_in_progress    - High for the duration of the SPI transaction
*
* Parameters:
*   SCK_DIVIDER             - Divisor for SCK generation
*   CS_WAIT_CYCLES          - Delay after CS low before SCK starts (min 15 us)
*   INTERBYTE_WAIT_CYCLES   - Delay between bytes (min 10 us)
*   POST_WAIT_CYCLES        - Delay after CS high before next transaction (min 25 us)
*
********************************************************************/

`timescale 1ns/1ps
module pmod_jstk2 (
    
    input wire clk, reset, start_read,           
    output reg sck, cs_n,            
    input wire miso,            
    output wire mosi,           
    output reg [15:0] x_position,   
    output reg [15:0] y_position,   
    output reg [7:0] fs_buttons,    
    output reg btn_jstk,        
    output reg btn_trigger,     
    output reg data_valid,      
    output wire read_in_progress
);

    
    parameter SCK_DIVIDER = 20; 
    parameter CS_WAIT_CYCLES = 1500; 
    parameter INTERBYTE_WAIT_CYCLES = 1000; 
    parameter POST_WAIT_CYCLES = 2500; 

    // FSM States 
    localparam [3:0] IDLE=0, CS_ASSERT=1, WAIT_CS_DELAY=2, SHIFT_BYTE=3, 
                     WAIT_INTERBYTE_DELAY=4, CS_DEASSERT=5, WAIT_POST_DELAY=6; 

    // Internal Signals
    reg [4:0] sck_count;
    wire sck_tick;          // Rising edge of SCK
    reg [3:0] current_state, next_state;
    reg [6:0] bit_count;    // Counts bits shifted in (0 to 39)
    reg [11:0] delay_count; 
    reg [39:0] received_data; 
    
    // SCK Generation
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            sck_count <= 0;
            sck <= 1'b0;
        end else if (current_state == SHIFT_BYTE) begin
            if (sck_count == SCK_DIVIDER - 1) begin
                sck_count <= 0;
                sck <= ~sck;
            end else begin
                sck_count <= sck_count + 1;
            end
        end else begin
            sck_count <= 0;
            sck <= 1'b0;
        end
    end

    // sck_tick marks the rising edge of the internal SPI clock for data sampling
    assign sck_tick = (current_state == SHIFT_BYTE) && (sck_count == SCK_DIVIDER - 1) && (sck == 0);
    
    assign mosi = 1'b0;
    assign read_in_progress = (current_state != IDLE) && (current_state != WAIT_POST_DELAY);

    // FSM - State Transition & Output Logic (Sequential)
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            current_state <= IDLE;
            bit_count <= 0;
            delay_count <= 0;
            received_data <= 40'h0;
            x_position <= 16'h0000;
            y_position <= 16'h0000;
            fs_buttons <= 8'h00;
            btn_jstk <= 1'b0;
            btn_trigger <= 1'b0;
        end else begin
            current_state <= next_state;
            
            // Delay Counter Logic
            if (current_state == WAIT_CS_DELAY || current_state == WAIT_INTERBYTE_DELAY || current_state == WAIT_POST_DELAY) begin
                delay_count <= delay_count + 1;
            end else begin
                delay_count <= 0;
            end

            // Bit Counter and Shift Register Logic
            if (current_state == SHIFT_BYTE && sck_tick) begin

                // Shift in one bit on the rising edge of SCK (MSB-first)
                received_data <= {miso, received_data[39:1]}; 
                bit_count <= bit_count + 1; 
            end else if (next_state == CS_ASSERT) begin
                bit_count <= 0; // Reset counter for new transfer
                received_data <= 40'h0;
            end
        end
    end

    // FSM - Next State & Output Logic (Combinational)
    always @(*) begin
        next_state = current_state;
        cs_n = 1'b1;
        data_valid = 1'b0;
        
        // Retain current output values unless updated in CS_DEASSERT
        x_position = x_position;
        y_position = y_position;
        fs_buttons = fs_buttons;
        btn_jstk = btn_jstk;
        btn_trigger = btn_trigger;

        case (current_state)
            IDLE: begin
                if (start_read) next_state = CS_ASSERT;
            end

            CS_ASSERT: begin
                cs_n = 1'b0;
                next_state = WAIT_CS_DELAY;
            end

            WAIT_CS_DELAY: begin
                cs_n = 1'b0;
                if (delay_count == CS_WAIT_CYCLES) next_state = SHIFT_BYTE;
            end

            SHIFT_BYTE: begin
                cs_n = 1'b0;
            
                if (sck_tick) begin
                    if (bit_count == 39) begin
                        next_state = CS_DEASSERT;           // Transfer complete after 40th bit
                    end else if (bit_count[2:0] == 7) begin
                        next_state = WAIT_INTERBYTE_DELAY;  // Byte complete
                    end
                end
            end

            WAIT_INTERBYTE_DELAY: begin
                cs_n = 1'b0;
                if (delay_count == INTERBYTE_WAIT_CYCLES) next_state = SHIFT_BYTE;
            end

            CS_DEASSERT: begin
                cs_n = 1'b1;
                data_valid = 1'b1;
                next_state = WAIT_POST_DELAY;
                
                // Parsing Logic
                // X Position
                x_position = {received_data[31:24], received_data[39:32]};

                // Y Position
                y_position = {received_data[15:8], received_data[23:16]};

                // fsButtons
                fs_buttons = received_data[7:0];

                // Buttons
                btn_trigger = received_data[1];
                btn_jstk = received_data[0];
            end

            WAIT_POST_DELAY: begin
                cs_n = 1'b1;
                data_valid = 1'b0;
                if (delay_count == POST_WAIT_CYCLES) next_state = IDLE;
            end

            default: next_state = IDLE;
        endcase
    end
endmodule